<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>German Cities Temperature Aggregator with Pirate Weather</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      background: #f4f4f4;
    }
    h1 { color: #333; }
    form { margin-bottom: 20px; }
    label { display: block; margin-bottom: 5px; }
    input, select { padding: 8px; width: 250px; margin-bottom: 10px; }
    button { padding: 8px 16px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { background: #333; color: #fff; }
    .loading { font-style: italic; }
    #progress { margin-top: 10px; }
  </style>
</head>
<body>
  <h1>German Cities Temperature Aggregator</h1>
  <form id="tempForm">
    <label for="apiKey">Pirate Weather API Key:</label>
    <input type="text" id="apiKey" placeholder="Enter your API Key" required>
    
    <label for="month">Select Month:</label>
    <select id="month">
      <option value="1">January</option>
      <option value="2">February</option>
      <option value="3">March</option>
      <option value="4">April</option>
      <option value="5">May</option>
      <option value="6">June</option>
      <option value="7">July</option>
      <option value="8">August</option>
      <option value="9">September</option>
      <option value="10">October</option>
      <option value="11">November</option>
      <option value="12">December</option>
    </select>
    
    <button type="submit">Get Temperature Sums</button>
  </form>
  
  <div id="progress"></div>
  <div id="results"></div>
  
  <script>
    // URL to fetch the list of all German cities in JSON format
    const citiesURL = "https://raw.githubusercontent.com/pensnarik/german-cities/master/germany.json";
    
    // For demonstration purposes, we limit the number of cities processed.
    // Set maxCities = 10 to test; change it to the full list length (or remove the limit) for production.
    const maxCities = 10; // <-- Change to e.g., Infinity or the actual count for all cities

    // Concurrency limit (number of cities processed in parallel)
    const concurrencyLimit = 5;
    
    document.getElementById('tempForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const apiKey = document.getElementById('apiKey').value.trim();
      if (!apiKey) {
        alert('Please enter your API Key.');
        return;
      }
      
      const month = parseInt(document.getElementById('month').value);
      const year = new Date().getFullYear();
      const daysInMonth = new Date(year, month, 0).getDate();
      
      const progressDiv = document.getElementById('progress');
      const resultsDiv = document.getElementById('results');
      progressDiv.textContent = "Loading cities...";
      
      // Fetch list of cities
      let cities;
      try {
        const res = await fetch(citiesURL);
        cities = await res.json();
      } catch (error) {
        alert("Error fetching cities: " + error);
        return;
      }
      
      // Optionally limit the cities processed (for demo/testing)
      if (maxCities && cities.length > maxCities) {
        cities = cities.slice(0, maxCities);
      }
      
      progressDiv.textContent = `Processing ${cities.length} cities over ${daysInMonth} days...`;
      
      // Helper function: delay in ms
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
      
      // Function to process one city:
      async function processCity(city) {
        const { name, coords } = city;
        if (!coords || !coords.lat || !coords.lon) {
          return { city: name, sum: "No coords" };
        }
        const lat = coords.lat;
        const lon = coords.lon;
        let sumAvgTemp = 0;
        let daysProcessed = 0;
        for (let day = 1; day <= daysInMonth; day++) {
          // Set time to noon (12:00) of that day for consistency
          const date = new Date(year, month - 1, day, 12, 0, 0);
          const timestamp = Math.floor(date.getTime() / 1000);
          // Build Pirate Weather time machine URL
          const url = `https://timemachine.pirateweather.net/forecast/${apiKey}/${lat},${lon},${timestamp}?units=ca&exclude=minutely,alerts,hourly`;
          try {
            const response = await fetch(url);
            if (!response.ok) {
              console.error(`Error for ${name} on ${date.toISOString().split('T')[0]}: ${response.statusText}`);
              continue;
            }
            const data = await response.json();
            // Expect a "daily" block with a "data" array – use the first element
            if (data.daily && data.daily.data && data.daily.data.length > 0) {
              const dayData = data.daily.data[0];
              const tempHigh = dayData.temperatureHigh;
              const tempLow = dayData.temperatureLow;
              // Compute average as (high + low) / 2
              if (typeof tempHigh === "number" && typeof tempLow === "number") {
                const avgTemp = (tempHigh + tempLow) / 2;
                sumAvgTemp += avgTemp;
                daysProcessed++;
              }
            }
          } catch (err) {
            console.error(`Fetch error for ${name} on ${date.toISOString().split('T')[0]}:`, err);
          }
          // Optional: small delay to avoid hammering the API (adjust as needed)
          await delay(200);
        }
        return { city: name, sum: daysProcessed ? sumAvgTemp.toFixed(2) : "N/A" };
      }
      
      // Limited concurrency runner for city tasks
      async function runLimited(tasks, limit) {
        const results = [];
        let index = 0;
        async function worker() {
          while (index < tasks.length) {
            const currentIndex = index++;
            try {
              const res = await tasks[currentIndex]();
              results[currentIndex] = res;
            } catch (err) {
              results[currentIndex] = { city: "Error", sum: "Error" };
            }
            progressDiv.textContent = `Processed ${currentIndex + 1} / ${tasks.length} cities...`;
          }
        }
        const workers = [];
        for (let i = 0; i < limit; i++) {
          workers.push(worker());
        }
        await Promise.all(workers);
        return results;
      }
      
      // Create an array of task functions for each city
      const cityTasks = cities.map(city => () => processCity(city));
      
      progressDiv.textContent = "Starting city processing...";
      const resultsArray = await runLimited(cityTasks, concurrencyLimit);
      
      // Build results table
      let html = '<table><thead><tr><th>City</th><th>Sum of Daily Avg Temperatures (°C)</th></tr></thead><tbody>';
      resultsArray.forEach(result => {
        html += `<tr><td>${result.city}</td><td>${result.sum}</td></tr>`;
      });
      html += '</tbody></table>';
      resultsDiv.innerHTML = html;
      progressDiv.textContent = "Processing complete.";
    });
  </script>
  <p style="margin-top:20px; font-size:0.9em;">
    Note: This demo makes a separate API call for every day and city. Processing all German cities may require thousands of calls and exceed API limits.
  </p>
</body>
</html>
